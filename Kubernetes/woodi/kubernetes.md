# 쿠버네티스

### 쿠버네티스란?

- 애플리케이션 배포, 스케일링, 관리를 자동화 하는 컨테이너 기반의 오케스트레이션 오픈 소스  플랫폼이다.

### 등장 배경

![image](https://user-images.githubusercontent.com/47748246/154841085-4d4d3275-5fb6-48c3-80f2-c6d70134d1ae.png)

**전통적인 배포 시대**

- 초기 조직은 애플리케이션을 물리 서버에서 실행했었다.
- 문제점
    - **한 물리 서버에서 여러 애플리케이션의 리소스 한계를 정의할 방법이 없었기 때문에**, 리소스 할당의 문제가 발생함. 하나의 애플리케이션 인스턴스가 리소스를 다 잡아먹으면, 다른 애플리케이션은 리소스 부족 문제 발생
    - 따라서 서로 다른 여러 물리 서버에서 각 애플리케이션을 실행함.
    - 그러나 이는 리소스가 충분히 사용되지 않는다는 점에서 확장 가능하지 않았으므로, 물리 서버를 많이 유지하기 위해서는 많은 비용이 들었다.

**가상화된 배포 시대**

- 위 문제의 해결책으로 가상화가 도입되었다.
- 이는 단일 물리 서버의 CPU에서 **여러 가상 시스템 (VM)**을 실행할 수 있게 한다. **가상화를 사용하면 VM 간에 애플리케이션을 격리**하고 애플리케이션의 정보를 다른 애플리케이션에서 자유롭게 액세스 할 수 없으므로, 일정 수준의 보안성을 제공할 수 있다.
- 가상화를 사용하면 물리 서버에서 리소스를 보다 효율적으로 활용할 수 있으며, 쉽게 애플리케이션을 추가하거나 업데이트할 수 있고 하드웨어 비용을 절감할 수 있어 더 나은 확장성을 제공한다. 가상화를 통해 일련의 물리 리소스를 폐기 가능한(disposable) 가상 머신으로 구성된 클러스터로 만들 수 있다.
- 각 VM은 **가상화된 하드웨어** 상에서 **자체 운영체제를 포함한 모든 구성 요소를 실행**하는 하나의 완전한 머신이다 .

**컨테이너 개발 시대**

- 컨테이너는 VM과 유사하지만 격리 속성을 완화하여 애플리케이션 간에 **운영체제(OS)를 공유**한다. 따라서 VM에 비해 가볍다.
- VM과 마찬가지로 컨테이너에는 자체 파일 시스템, CPU  점유율, 메모리, 프로세스 공간 등이 있다.
- 기본 인프라와의 종속성을 끊었기 때문에, 클라우드나 OS 배포본에 모두 이식할 수 있다.

### 쿠버네티스가 필요한 이유

- 프로덕션 환경에서는 애플리케이션을 실행하는 컨테이너를 관리하고 가동 중지 시간이 없는지 확인해야 한다. 예를 들어 컨테이너가 다운되면 다른 컨테이너를 다시 시작해야 한다. ⇒ 이 작업을 사람이 직접하는 것보다는 시스템에 의해 자동으로 처리하면 더 편할 것이다 .
- 바로 위 역할을 쿠버네티스가 맡는다. **쿠버네티스는 분산 시스템을 탄력적으로 실행하기 위한 프레임워크를 제공**한다. 즉, 애플리케이션의 확장과 장애 조치를 처리하고, 배포 패턴 등을 제공한다. 예를 들어, 쿠버네티스는 시스템의 카나리아 배포를 쉽게 관리 할 수 있다.
- 쿠버네티스가 제공하는 기능들
    - **서비스 디스커버리와 로드밸런싱**
        - 쿠버네티스는 **DNS 이름**을 사용하거나 **자체 IP 주소**를 사용하여 **컨테이너를 노출**할 수 있다.
        - 컨테이너에 대한 트래픽이 많으면, 쿠버네티스는 **네트워크 트래픽을 로드밸런싱**하고 **배포**하여 배포가 안정적으로 이루어질 수 있다.
    - **스토리지 오케스트레이션**
        - 쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재할 수 있다.
    - **자동화된 롤 아웃과 롤백**
        - 쿠버네티스를 사용하여 **배포된 컨테이너의 원하는 상태를 서술**할 수 있으며 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있다.
        - 예 : 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용할 수 있다.
    - **자동화된 빈 패킹 (bin packing)**
        - **컨테이너화된 작업을 실행**하는데 사용할 수 있는 쿠버네티스 **클러스터 노드**를 제공한다.
        - 각 **컨테이너가 필요로 하는 CPU와 메모리(RAM)를 쿠버네티스에게 지시**한다.
        - 쿠버네티스는 컨테이너를 노드에 맞추어서 리소스를 가장 잘 사용할 수 있도록 해준다.
    - **자동화된 복구 (self-healing)**
        - 쿠버네티스는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, ‘사용자 정의 상태 검사’에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에게 보여주지 않는다.
    - **시크릿 구성 관리**
        - 쿠버네티스를 사용하면 암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리 할 수 있다.
        - 컨테이너 이미지를 재구성하지 않고 스택 구성에 시크릿을 노출하지 않고도 시크릿 및 애플리케이션 구성을 배포 및 업데이트할 수 있다.

### 쿠버네티스 컴포넌트

- 쿠버네티스를 배포하면 클러스터를 얻는다.
- 쿠버네티스 클러스터 : Node의 집합
- 워커 노드는 애플리케이션의 구성 요소인 pod를 호스트한다.
- 컨트롤 플레인은 워커 노드와 클러스터 내 파드를 관리한다.
- 프로덕션 환경에서는 일반적으로 컨트롤 플레인이 여러 컴퓨터에 걸쳐 실행되고, 클러스터는 일반적으로 여러 노드를 실행하므로 내결함성과 고가용성이 제공된다.

![image](https://user-images.githubusercontent.com/47748246/154841090-8697fa64-00da-4045-9937-80284a949142.png)
