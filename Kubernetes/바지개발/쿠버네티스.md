
# Docker

![Untitled](https://user-images.githubusercontent.com/90545926/154841004-0e53e138-1a2d-4357-bf4f-208b7f65d96b.png)

## 가상머신

-   기존의 서버에 하이퍼바이저를 설치하고, 그 위에 가상 OS와 APP를 패키징한 VM을 만들어 실행하는 방식인 **하드웨어 레벨의 가상화**를 지원
    
    ※ 하이퍼바이저 : 하드웨어와 가상머신들 사이에서 하드웨어를 가상화하기 위해 하드웨어들을 제어할 뿐만 아니라 각각의 가상머신들을 관리하는 역할. 하드웨어의 물리적인 리소스를 VM들에 제공하고 하드웨어간 I/O명령을 처리하며 VM이 동작할 수 있는 환경을 제공
    

## 컨테이너

-   운영체제를 제외한 나머지 애플리케이션 실행에 필요한 모든 파일을 패키징한다는 점에서 **OS레벨 가상화**를 지원
-   게스트 OS와 하이퍼바이저가 없기 때문에 이로 인한 오버헤드를 줄임으로써 훨씬 더 가볍게 프로세스를 실행
-   컨테이너에 대한 복제와 배포가 더 용이
-   여러개의 컨테이너가 동일한 호스트에서 커널을 공유하며 실행
-   커널은 공유하지만 개별적인 ‘사용자 공간’을 가지고 있음

# 쿠버네티스

## 쿠버네티스

-   여러 서버로 구성된 클러스터 환경에서 컨테이너화된 프로세스를 관리하기 위한 컨테이너 오케스트레이션 플랫폼
    
-   여러 컴퓨터의 집합으로 이루어진 거대한 시스템을 추상적으로 제어할 수 있는 사용자 인터페이스를 제공하고, 컨테이너가 정상적으로 실행될 수 있게 여러가지 기능을 제공하는 데이터 센터 운영체제 또는 클러스터 운영체제
    
-   쿠버네티스를 통해 컨테이너의 배포, 확장 및 스케줄링을 자동화해 전반적인 라이프사이클을 관리함
    
    ※ 컨테이너 오케스트레이션 : 컨테이너를 여러 서버에 걸쳐 여러 개를 실행시키는 데 체계적으로 관리하는 기술
    

## 쿠버네티스의 역할

-   컨테이너의 실행 및 배포
-   컨테이너의 이중화와 가용성보장
-   컨테이너의 수평확장 및 축소 관리
-   컨테이너의 스케줄링 담당
-   컨테이너의 네트워크 설정 관리
-   컨테이너의 health 상태를 모니터링
-   컨테이너의 설정값을 관리
-   하드웨어 추상화 기능 제공 : 사용자가 개별 노드(서버)를 직접 제어하지 않고 쿠버네티스라는 추상화된 레이어를 통해 클러스터를 제어

## 쿠버네티스 기본 개념

### 마스터, 워커노드

-   서버마다 특정 역할(웹서버, 빌드서버 등)이 정해지지 않고, 워커 서버로 동일
-   모든 서버들은 마스터와 워커로만 구분
-   마스터에는 쿠버네티스를 운용하기 위한 필수적인 핵심 컴포넌트가 존재
-   워커노드는 단순히 컨테이너를 실행하는 환경으로 사용

### 바라는 상태

-   사용자의 요청에 따라 현재 상태가 바라는 상태(Desired State)와 동일해지도록 사전에 미리 정의된 특정 작업을 수행(장애가 발생해도 바라는 상태로 되살릴 수 있음)
-   컨트롤러는 현재 상태를 사용자가 바라는 상태로 변경시키는 주체
-   컨트롤러는 control-loop를 돌며 특정 리소스를 지속적으로 모니터링을 하다가 사용자가 생성한 리소스(바라는 상태)의 이벤트에 따라 사전에 정의된 작업을 수행

### 리소스

-   Pod은 가장 기본적인 리소스로 하나 이상의 컨테이너를 가지는 쿠버네티스의 최소 실행 단위
-   쿠버네티스에서 프로세스를 실행한다는 의미는 Pod 리소스를 생성하는 것과 같음

### 선언형 커맨드

-   사용자가 직접 시스템의 상태를 바꾸지 않고 사용자가 바라는 상태를 선언적으로 기술하여 명령을 내림
-   YMAL형식의 리소스인 YAML 정의서를 이용해 선언형 명령을 내림

### 네임스페이스

-   클러스터를 논리적으로 분리하는 네임스페이스로 클러스터 환경을 나눔
-   네임스페이스로 클러스터 환경을 나눔

### 라벨&셀렉터

-   특정 리소스에 명령을 전달하거나 정보를 확인하고 싶을 때 라벨링 시스템을 이용
-   라벨링 시스템을 이용하여 질의하기 위해서 먼저 리소스에 key-value형식의 태그정보(라벨)을 붙임
-   태깅한 리소스를 찾기 위해 셀렉터를 이용해 특정 key-value를 가진 리소스만 추출

### 서비스 탐색

-   서비스 탐색 기능을 Service라는 리소스를 이용해 제공
-   사용자(또는 Pod)는 서비스 끝점(service Endpoint)을 통해 다른 컨테이너(Pod)와 통신 할 수 있음
-   쿠버네티스에서는 DNS 기반의 서비스 탐색을 지원해 도메인 주소를 기반으로 서비스에 접근 가능

### 설정관리

-   컨테이너를 실행할 때 필요한 설정값 및 민감정보를 플랫폼 레벨에서 관리할 수 있게 제공
-   ConfigMap또는 Secret이라는 리소스를 이용

## 아키텍쳐

### 마스터

-   마스터는 단일한 서버로 구성하거나, 고가용성을 위해 여러 서버를 묶어 클러스터 마스터로도 구축할 수 있음
-   kube-apiserve r: 마스터로 전달되는 모든 요청을 받아드리는 REST API 서버
-   etcd : 클러스터내 모든 메타 정보를 저장하는 저장소(key-value 형태)
-   kube-scheduler : 사용자의 요청에 따라 적절하게 컨테이너를 워커 노드에 배치하는 스케줄러
-   kube-controller-manager : 현재 상태와 바라는 상태를 지속적으로 확인하며 특정 이벤트에 따라 특정 동작을 수행하는 컨트롤러
-   cloud-controller-manager : 클라우드 플랫폼(AWS, GCP, Azure 등)에 특화된 리소스를 제어하는 클라우드 컨트롤러

### 노드

-   kubelet : 마스터의 명령에 따라 컨테이너의 라이프 사이클을 관리하는 노드 관리자
-   kube-proxy : 컨테이너의 네트워킹을 책임지는 프록시
-   container-runtime : 실제 컨테이너를 실행하는 컨테이너 실행환경

## 쿠버네티스 장점 정리

-   실행 환경 고립화 : 개별 실행 환경 고민 없이 프로세스를 어디서나 실행시킬 수 있음
-   여러 서버를 체계적으로 관리할 수 있음
-   쿠버네티스 내장 스케줄러가 최적의 노드를 찾아 컨테이너를 배치
-   클러스터 레벨에서 프로세스 관리를 편리하게 함. 클러스터 내에서 실행되고 있는 모든 컨테이너를 명령 하나로 확인 할 수 있음
-   개별적인 서버의 설정값을 통합하여 관리
-   쿠버네티스는 프로세스마다 리소스 사용량을 제한시킬 수 있어 다른 프로세스에 영향을 주지 않을 수 있고, 서버 자체에 장애가 발생하면 손쉽게 다른 서버로 교체할 수 있음
-   평소에는 최소한의 자원만 준비하고, 필요 시 자동으로 리소스 추가함으로 운영비용을 최소화하고 안정성을 높일 수 있음
-   동일 스택으로 클라우드 플랫폼이나 온프레미스 환경에서 운영가능
-   컨테이너에 문제가 생기더라도 현재 상태가 바라는 상태와 달라진 것을 인지하고 컨테이너를 다시 실행
-   다양한 데이터 저장소를 자동으로 관리함
-   쿠버네티스가 배포작업을 자동으로 수행
