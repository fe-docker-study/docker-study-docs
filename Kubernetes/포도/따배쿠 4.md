# 쿠버네티스 아키텍처
## 쿠버네티스 동작 원리
쿠버네티스는 선언형 API를 사용하여 내용이 etcd에 저장되고, etcd를 모니터링하던 controller에 의해 동작하게 됨
+ 명령형 API : 일반적으로 사용하는 CLI 명령어 방식
+ 선언형 API : 원하는 결과만을 제시하고, 시스템이 스스로 결과를 얻게 해 주는 API
+ etcd : 분산 시스템에서 사용할 수 있는 분산형 키-값 (key-value) 저장소    

### 쿠버네티스 동작 순서
1. 클라이언트가 쿠버네티스 API 서버에 요청 : 일반적으로 kubectl을 사용하여 요청
2. etcd에 API 내용 저장
3. etcd를 감시하던 controller 동작 : controller가 etcd에 담당하고 있는 resource가 들어왔는지 감시하다가 자신의 역할에 맞는 내용이 저장되어 있다면 스케줄러에게 동작을 요청
4. 스케줄러가 워커노드의 kubectl과 통신
5. kubelet이 노드에 pod 등을 생성 

### 쿠버네티스 컴포넌트
+ 마스터 컴포넌트
  + etcd : key-value 타입의 저장소
  + kube-apiserver : k8s API를 사용하도록 요청을 받고 요청이 유효한지 검사
  + kube-scheduler : 파드를 실행할 노드 선택
  + kube-controller-manager : 파드를 관찰하며 개수를 보장
+ 워커 노드 컴포넌트
  + kubelet : 모든 노드에서 실행되는 k8s 에이전트, 데몬 형태로 동작
  + kube-proxy : k8s의 동작을 관리, iptables rule을 구성
  + 컨테이너 런타임 : 컨테이너를 실행하는 엔진으로 docker, containerd, runc 등  

### 애드온(Addons)
클러스트 내부에서 필요한 기능들을 위해 실행되는 pod들로, 디플로이먼트, 리플리케이션 컨트롤러 등에 의해 관리됨  
애드온이 사용하는 네임스페이스 : kube-system
+ 네트워킹 애드온
+ DNS 애드온
+ 대시보드 애드온
+ 컨테이너 자원 모니터링
+ 클러스터 로깅

<br>

## namespace
k8s namespace
+ namespace : 클러스터 하나를 여러 개의 논리적인 단위로 나눠서 사용하는 k8s API 종류 중 하나 (쿠버네티스 클러스터 내의 논리적인 분리 단위)  
  **주의 : namespace는 논리적인 구분 단위이며, 물리적으로 분리하는 것은 아님**
+ 쿠버네티스 클러스터 하나를 여러 팀이나 사용자가 함께 공유
+ 용도에 따라 실행해야 하는 앱을 구분할 때 사용  

![namespace](https://user-images.githubusercontent.com/77559262/157604877-0485e5be-9926-4fc7-a84b-180ba6b6543a.png)
해당 그림에서 dev 목적의 사용자는 dev namespace에 접근하여 오브젝트를 배치/운영하고, stage 목적의 사용자는 stage namespace에 접근하여 오브젝트를 배치/운영

### namespace 사용하기
+ namespace 생성
    + CLI
    ```
    $ kubectl create namespace blue
    $ kubectl get namespaces 
    ```
    kubectl get namespaces : 현재 시스템의 네임스페이스 확인  
    
    + yaml  
    ```
    $ kubectl create namespace green --dry-run -o yaml > green-ns.yaml
    $ vim green-ns.yaml
    $ kubectl create -f green-ns.yaml
    ```
+ namespace 관리
```
$ kubectl get namespace
$ kubectl delete namespace
```
<br>

## yaml 템플릿과 API

<br>

